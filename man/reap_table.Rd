% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reap-table.R
\name{reap_table}
\alias{reap_table}
\title{Extract data from HTML tables}
\usage{
reap_table(x, raw = FALSE, trim = TRUE)
}
\arguments{
\item{x}{a \code{reapr_doc} or anyting you're used to passing to \code{\link[rvest:html_table]{rvest::html_table()}}}

\item{raw}{if \code{TRUE} then a \code{list} with rows and cells will be returned. Each
cell has the value in the source HTML table but also has an \code{hattr}
attribute (short for "html entity attribute") which contains all the
attributes (if any) of the table cell. Each row in the list also has an \code{hattr}
attribute holding its attributes (if any). This structure may be useful
for doing more infolved extractions of weirdly formed HTML tables
without having to muck with XPath queries. Default: \code{FALSE}}

\item{trim}{if \code{TRUE} trim cell whitespace. Default: \code{FALSE}.}
}
\description{
This behaves differently than \code{\link[rvest:html_table]{rvest::html_table()}}. It does an
aggressive fill by default when \code{colspan}s or \code{rowspan}s are detected
and does not make any attempt to go beyond providing a basic data frame
of the HTML table. See \code{Details} for more information.
}
\details{
The functionality provided in \code{\link[rvest:html_table]{rvest::html_table()}} is double-plus good so
the intent of this function was not to subvert it. Rather, \code{\link[=reap_table]{reap_table()}}
was designed to give you more direct R-access to the underlying structure
of an HTML table so you can wrangle it as you please. In "raw" mode,
you get a list with attributes enabling you to work with the table structure,
cell values and entity attributes with R idioms vs XPath queries.
}
\note{
When passing in a \code{reapr_doc} object, the pre-parsed HTML will be
tested for validity and re-generated if the external pointer is
invalid.
}
\examples{
x <- reap_url("https://en.wikipedia.org/wiki/Demography_of_the_United_Kingdom")

# take advantage of the pre-processing reap_url() does:
tbl <- reap_table(x$tag$table[[10]])
tbl_raw <- reap_table(x$tag$table[[10]], raw=TRUE)

# get all of 'em:
tbls <- reap_table(x)

# fid a specific one:
reap_node(x, ".//table[contains(., 'Other identity and at least one UK identity')]") \%>\%
  reap_table() -> tbl
}
